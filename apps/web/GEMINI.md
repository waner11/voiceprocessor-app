# Gemini Project: VoiceProcessor Web

This document provides a comprehensive overview of the VoiceProcessor Web project, designed to serve as an instructional context for team members and AI assistants.

## Project Overview

VoiceProcessor Web is the frontend application for a multi-provider Text-to-Speech (TTS) platform. It allows users to convert long-form text into natural-sounding audio using various TTS providers. The application is built with Next.js 14+ (App Router) and TypeScript, utilizing Tailwind CSS for styling and Zustand/React Query for state management.

### Key Features:

-   Convert long-form text to audio.
-   Select from multiple TTS providers (ElevenLabs, OpenAI, Google, Amazon Polly).
-   Preview audio before generating the full file.
-   Download audio in various formats.
-   Track usage and manage subscriptions.

### Architecture & Tech Stack:

-   **Framework**: Next.js 14+ (App Router)
-   **Language**: TypeScript
-   **Styling**: Tailwind CSS + shadcn/ui
-   **State Management**:
    -   **Server State**: TanStack Query (React Query)
    -   **Client State**: Zustand
-   **Forms**: React Hook Form + Zod
-   **Real-time**: SignalR (@microsoft/signalr)
-   **Audio**: wavesurfer.js
-   **API Client**: `openapi-fetch` with an auto-generated client from an OpenAPI specification.
-   **Testing**: Vitest (unit), Playwright (E2E)

### Directory Structure

```
src/
├── app/           # Next.js App Router pages
├── components/    # Reusable UI components
├── features/      # Feature-specific components and logic
├── hooks/         # Custom React hooks
├── lib/           # Utilities, API client, SignalR
├── stores/        # Zustand stores
└── types/         # TypeScript types
```

### Real-time Updates

SignalR WebSocket connection provides live progress updates for audio generation jobs. Updates are integrated with React Query cache for seamless UI updates.

## Building and Running

### Prerequisites:

-   Node.js 20+
-   pnpm

### 1. Install Dependencies:

```bash
pnpm install
```

### 2. Set Up Environment:

Copy the example environment file and edit it with your backend API URL.

```bash
cp .env.example .env.local
```

**`.env.local`**

```
NEXT_PUBLIC_API_URL=http://localhost:5000    # Backend API URL
NEXT_PUBLIC_APP_ENV=development              # Environment type
```

### 3. Run Development Server:

```bash
pnpm dev
```

The application will be available at `http://localhost:3000`.

### Key Scripts:

| Command           | Description                                       |
| ----------------- | ------------------------------------------------- |
| `pnpm dev`        | Start the development server with Turbopack.      |
| `pnpm build`      | Build the application for production.             |
| `pnpm start`      | Start the production server.                      |
| `pnpm lint`       | Run ESLint to check for code quality issues.      |
| `pnpm test`       | Run unit tests with Vitest.                       |
| `pnpm test:e2e`   | Run end-to-end tests with Playwright.             |
| `pnpm generate:api` | Generate the API client from the OpenAPI spec.    |

## Development Conventions

### API Client:

The API client is generated from an OpenAPI specification using `openapi-typescript`. To update the client, run `pnpm generate:api --spec <URL_or_path_to_spec>`. This ensures type safety between the frontend and backend.

### State Management:

-   **Zustand**: Used for global UI state and authentication state.
-   **TanStack React Query**: Used for server state, including caching data fetched from the API.

### Styling:

-   **Tailwind CSS**: Utility-first CSS framework for styling.
-   **shadcn/ui**: Reusable components built with Radix UI and Tailwind CSS.
-   **clsx** and **tailwind-merge**: For conditional and merging of class names.
-   **lucide-react**: For icons.

### Commit Messages

Write commit messages like a human developer would. Keep them natural and concise.

**Rules:**
- Never add "Co-Authored-By", "Generated by", or any AI attribution
- No overly formal or verbose descriptions
- Use lowercase, imperative mood (e.g., "fix", "add", "update")
- One line is usually enough; add body only if truly needed

**Good examples:**
```
fix voice selector not updating on provider change
add cost estimate component
handle empty text input gracefully
update api client for new generation endpoint
```

## Issue Tracking (bd/beads)

This project uses `bd` for issue tracking. Key commands:

```bash
bd ready              # Find available work
bd show <id>          # View issue details
bd update <id> --status in_progress
bd close <id>         # Complete work
bd sync --from-main   # Pull beads updates (for ephemeral branches)
```

**Workflow Rule:**
When working on an issue, you MUST:
1.  Create a new git branch named after the issue ID (e.g., `git checkout -b voiceprocessor-web-123`).
2.  Work on the issue in that branch.
3.  Create a Pull Request (PR) to merge into `main` when finished.

## Related Repositories

- **Backend API:** `/home/wanerpena/Documents/Projects/voiceprocessor-api`
